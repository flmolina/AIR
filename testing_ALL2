import matplotlib.pyplot as plt
import numpy as np
import pyaudio
import struct
import classes_n_functions as cnf

# Configuración de la grabación
FORMAT = pyaudio.paInt16  # Formato de audio
CHANNELS = 1  # Número de canales (1 para mono, 2 para estéreo)
fs = 48000  # Tasa de muestreo (muestras por segundo)
# Número de muestras por bloque
##Parametros del sistema
tstep = 1 / fs  # Tiempo de muestreo
f0 = 60  # Frecuencia fundamental a analizar
CICLOS = 2
N = int(fs / f0) * CICLOS  ##Numero CICLOS A ANALIZAR

# Inicializar PyAudio
p = pyaudio.PyAudio()

# Abrir un stream para la entrada de audio en tiempo real
stream = p.open(format=FORMAT,
                channels=CHANNELS,
                rate=fs,
                input=True,
                frames_per_buffer=N,
                input_device_index=1)

fig, ax = plt.subplots()
ax.set_ylim(-10000, 10000)
x = np.arange(0, N, 1)
DATAS = []
DATAS2=[]
line, = ax.plot(x, np.random.rand(int(N)))
fig.show()

# Inicializar variables para la superposición
overlap_data = []

for i in range(0, 100):
    data = stream.read(N, exception_on_overflow=False)
    data_int = struct.unpack(str(N) + "h", data)

    FFT = cnf.True_FFT(data_int, N)
    #print(round(cnf.data_Mag(FFT, CICLOS), 3))
    line.set_ydata(data_int)

    # Superposición de datos
    overlapped_data = overlap_data + list(data_int)
    overlap_length = 0

    # Buscar punto de repetición
    for j in range(N, len(overlapped_data)):
        if overlapped_data[j] == overlapped_data[j - N]:
            overlap_length = j
            break

    DATAS.append(overlapped_data[:overlap_length])
    DATAS2.append(data_int)
    # Actualizar datos superpuestos para la próxima iteración
    overlap_data = overlapped_data[overlap_length:]
    print(len(overlap_data))


    fig.canvas.draw()
    fig.canvas.flush_events()

plt.plot(x, DATAS2[-1], label="Muestra delante")
plt.plot(x, DATAS2[-2], label="Muestra")
plt.plot(x, DATAS2[-3], label="Muestra detras")
plt.legend()
plt.show()

